<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>canvas drawing exam</title>
  <style>
    #canvas {
      border: 3px solid #000000;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="600"></canvas>
  
  <script>
  // //canvas 선언
  // const canvas = document.getElementById('canvas');
  // // 2d모드의 그리기 객체 취득
  // const ctx = canvas.getContext('2d');
  // var canvasWidth = canvas.clientWidth
  // var canvasHeight = canvas.clientHeight
  
  
  // # 1, 색을 설정 - 파란색 사각형을 그린다.
  // ctx.fillStyle = 'blue';
  // ctx.fillRect(50, 50, 200, 200);
  
  // 캔버스를 지운다.
  // ctx.clearRect(0, 0, 600, 600);

  // 선을 그린다.
  // ctx.moveTo(0, 0);
  // ctx.lineTo(300, 300);
  // ctx.lineTo(600, 0);
  // ctx.stroke();

  // 원을 그린다.
  // ctx.beginPath();
  // ctx.arc(300, 300, 300, 0, 2 * Math.PI);// pi가 180도, 2를 그리면 반원에 대한 제곱
  // ctx.stroke();
  // ctx.fill();

  //연습 문제
  // ctx.fillRect(50, 50, 200, 200);
  // ctx.fillRect(300 , 300, 250, 250);

  // # 2, 반지름이 30 짜리 호를 그린다. 
  // ctx.beginPath();
  // ctx.arc(300, 300, 100, Math.PI, 2 * Math.PI);// pi가 180도, 2를 그리면 반원에 대한 제곱
  // ctx.stroke();

  // # 2-1, 캔버스를 가로지르는 대각선
  // ctx.clearRect(0, 0, 600, 600);
  // ctx.moveTo(0,0);
  // ctx.lineTo(600, 600);
  // ctx.stroke();

  // # 2-2, 마름모와 그에 내접하는 사각형 그리기
  // ctx.moveTo(300, 0);
  // ctx.lineTo(0, 300);
  // ctx.lineTo(300, 600);
  // ctx.lineTo(600, 300);
  // ctx.lineTo(300, 0);
  // ctx.stroke();

  // 내접 사각형
  // ctx.clearRect(0, 0, canvasWidth, canvasHeight)
  // ctx.moveTo(150, 150);
  // ctx.lineTo(450, 150);
  // ctx.lineTo(450, 450);
  // ctx.lineTo(150, 450);
  // ctx.lineTo(150, 150);
  // ctx.stroke();

  // 내접 사각형 안에 내접하는 원 그리기
  // ctx.moveTo(450, 300);
  // ctx.arc(300, 300, 150, 0, 2 * Math.PI);
  // ctx.stroke();


  // 추가 연습

  // 삼각형 그리기
  // ctx.clearRect(0, 0, 600, 600);
  // ctx.moveTo(300, 150);
  // ctx.lineTo(150, 450);
  // ctx.lineTo(450, 450);
  // ctx.lineTo(300, 150);
  // ctx.stroke();

  // // 삼각형 내변 삼각형
  // ctx.moveTo(225, 300);
  // ctx.lineTo(375, 300);
  // ctx.lineTo(300, 450);
  // ctx.lineTo(225, 300);
  // ctx.stroke();


  // // # 3, 곡선 그리기, 조절 점이 있다.
  // var controlX = 100;
  // var controlY = 450;
  // var controlX = Math.random() * canvasWidth;
  // var controlY = Math.random() * canvasHeight;


  // // # 3-1, 조절점을 보여준다.
  // ctx.beginPath();
  // ctx.arc(controlX, controlY, 5, 0, Math.PI * 2);
  // ctx.fill();

  // // # 3-2, 랜덤 사선
  // ctx.beginPath();
  // ctx.moveTo(0, 0);
  // ctx.quadraticCurveTo(controlX, controlY, canvasWidth, canvasHeight);
  // ctx.stroke();

  // # 4, 곡선으로 원 그리기
  // ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  // ctx.moveTo(canvasWidth/2, 0);
  // ctx.quadraticCurveTo(0, 0, 0, canvasWidth/2);
  // // #2
  // ctx.moveTo(0, 300);
  // ctx.quadraticCurveTo(0, 600, canvasWidth/2, canvasHeight);
  // // #3
  // ctx.moveTo(300, 600);
  // ctx.quadraticCurveTo(600, 600, canvasWidth, canvasHeight/2);
  // // #4
  // ctx.moveTo(600, 300);
  // ctx.quadraticCurveTo(600, 0, canvasWidth/2, 0);
  // // 출력
  // ctx.stroke();

  // // # 5, 임의의 점을 찍어서 연결한다. 점 갯 수 설정, 이 점이 콘트롤 포인트가 된다.
  // ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  // let count = 4;

  // // # 5-1, 캔버스 양 끝에 점이 그려지기 위해서 점의 수 -1을 캔버스 가로 크기에 나누어 줌
  // var canvasGap = canvasWidth / (count-1);
  // // x, y 좌표를 갖는 점들의 값을 저장하기 위해 배열 선언
  // var points = [];

  // // 커브를 그리기 위한 count + 1
  // for(let i = 0; i < count + 1; i++) {
  //   let point = {
  //     x : 0,
  //     y : 0
  //   }
  //   point.x = canvasGap * i;
  //   point.y = Math.random() * canvasHeight; //랜덤 변수 곱하기 캔버스 높이를 곱해서 임의의 y 좌표를 갖는 점 생성
  //   points[i] = point;
  // }


  // // # 5-2, 임의의 x, y 좌표값에 반지름이 10인 원을 그리기
  // for( let i = 0; i < count; i++ ) {
  //   ctx.beginPath();
  //   ctx.arc(points[i].x, points[i].y, 10, 0, 2*Math.PI);
  //   ctx.fill();
  // }

  // // 임의의 점 직선 연결 - 2차 베지어 곡선 
  // ctx.moveTo(points[0].x, points[0].y);

  // for ( let i = 1; i < count; i++ ) {
  //   ctx.lineTo(points[i].x, points[i].y);
  //   ctx.stroke();
  // }

  // ctx.strokeStyle = "red";
  // ctx.beginPath();
  // ctx.moveTo(points[0].x, points[0].y);

  // for ( let i = 0; i < count; i++ ) {
  //   var centerX = ( points[i].x + points[i+1].x ) / 2;
  //   var centerY = ( points[i].y + points[i+1].y ) / 2;
  //   ctx.quadraticCurveTo(points[i].x, points[i].y, centerX, centerY);
  //   ctx.stroke();
  // }


  // # 6, 애니메이션 영역을 그리는 방법은 두가지가 있다. 시간함수를 사용해서 그리는 방법
  // var end = Math.PI * 2;      // 원의 끝점 선언
  // var sec = 2;                // 총 그리는 시간 선언
  // var fps = 60;               // Frame per seconds 설정
  // var multiply = fps * sec ;  

  // for ( var i = 0; i < multiply+1; i++ ) { drawSet(i); }; // multiply 만큼 반복해서 그려야 함.

  // function drawSet(delay) {
  //   setTimeout(() => { // 명령어를 특정 시간에 시작하고 싶을 때 사용한다.
  //     ctx.clearRect(0, 0, 600, 600);
  //     ctx.beginPath();
  //     ctx.arc(200, 200, 100, 0, end / multiply * delay); // 한번에 그리는 각도는 end 나누기 multiply
  //     ctx.stroke();
  //     console.log("set");
  //   }, delay * 1000 / fps ); // 1초가 1000이므로 1000을 fps로 나누면 그에 맞는 지연시간 설정 가능
  // }

  // 리퀘스트 애니메이션 프레임 - 브라우저에서 제공하는 내장함수, 재귀함수(=함수가 본인을 호출해서 무한하게 반복된다.)
  // let x = 0;
  // let myAni;

  // // 무한 반복하는 애니메이션
  // function drawReqInfi() {
  //   ctx.clearRect(200, 200, 400, 400);
  //   ctx.beginPath();
  //   ctx.arc(300, 300, 50, 0, Math.PI * x, false);
  //   ctx.stroke();
  //   x += 1 / 60;
  //   console.log("Infi");

  //   requestAnimationFrame(drawReqInfi);
  // }
  // drawReqInfi();

  // 스탑 
  // var y = 0;
  // var myAni2;

  // function drawReqStop() {
  //   ctx.clearRect(400, 400, 600, 600);
  //   ctx.beginPath();
  //   ctx.arc(500, 500, 50, 0, Math.PI * y, false);
  //   ctx.stroke();
  //   y += 1 / 60;
  //   console.log("Stop");

  //   myAni2 = requestAnimationFrame(drawReqStop);

  //   if ( y > 2 ) { cancelAnimationFrame(myAni2); }
  // }
  // drawReqStop();    

  </script>

</body>
</html> 
